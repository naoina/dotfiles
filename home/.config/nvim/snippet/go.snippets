snippet in "interface{}" !w
interface{}
endsnippet

snippet "^main" "main()" !rbA
func main() {
	${0:// TODO: not implemented yet}
}
endsnippet

snippet "^init" "init()" !rbA
func init() {
	${0:// TODO: not implemented yet}
}
endsnippet

snippet v "var" !b
var ${1:name} ${2:string}
endsnippet

snippet co "const" !b
const (
	${1:name}${2: = ${3:value}}
)
endsnippet

snippet = ":=" !iw
${1:name} := ${2:value}
endsnippet

snippet , "_, err" !iw
${1:_}, ${2:err}
endsnippet

snippet for "for" !b
for ${1:cond} {
	${0:${VISUAL}}
}
endsnippet

snippet forr "for _, v := range ..." !b
for ${2:_}, ${3:v} := range ${1:collection} {
	${0:${VISUAL}}
}
endsnippet

snippet fori "for i := 0; i < n; i++" !b
for ${2:i} := 0; $2 < ${1:n}; $2++ {
	${0:${VISUAL}}
}
endsnippet

snippet if "if" !w
if ${1:cond} {
	${0:${VISUAL}}
}
endsnippet

snippet ife "if err != nil" !b
if err != nil {
	${0:${VISUAL}}
}
endsnippet

snippet ifo "if !ok" !b
if !ok {
	${0:${VISUAL}}
}
endsnippet

snippet ifel "if err != nil" !b
if ${1:err} := ${2:Some}; err != ${3:nil} {
	${0:return err}
}
endsnippet

snippet f "func" "re.match('f(?!.*:=)', snip.buffer[snip.line])" !iwe
func ${1:FuncName}($2) $3{
	${0:${VISUAL}}
}
endsnippet

snippet "(\S+\s*)?fn" "func literal" !wr
`!p if match.group(1) is not None: snip.rv = match.group(1)`func() {
	${0:${VISUAL}}
}`!p if match.group(1) is None: snip.rv = '()'`
endsnippet

snippet fne "func() error" !w
func() error {
	${0:${VISUAL}}
}
endsnippet

snippet go "go func()" !b
go func() {
	${0:${VISUAL}}
}()
endsnippet

snippet m "method" !b
func (${1:receiver}) ${2:MethodName}($3) $4 {
	${0:${VISUAL}}
}
endsnippet

snippet type "type" !b
type ${1:name} ${2:type}
endsnippet

snippet t "type ... struct" !b
type ${1:name} struct {
	${0:// TODO: not implemented yet}
}
endsnippet

snippet struct "type ... struct" !b
type ${1:name} struct {
	${0:// TODO: not implemented yet}
}
endsnippet

snippet ti "type ... interface" !b
type ${1:name} interface {
	${0:// TODO: not implemented yet}
}
endsnippet

snippet interface "type ... interface" !b
type ${1:name} interface {
	${0:// TODO: not implemented yet}
}
endsnippet

snippet sw "switch" !b
switch ${1:expr} {
case ${2:cond}:
	${0:// TODO: not implemented yet}
}
endsnippet

snippet sel "select" !b
select {
case <-${1:ch}:
	${0:// TODO: not implemented yet}
}
endsnippet

snippet case "case" !b
case ${1:cond}:
	${0:// TODO: not implemented yet}
endsnippet

snippet p "fmt.Printf" !b
fmt.Printf("%#v\n", ${0:${VISUAL}})
endsnippet

snippet ft "func TestXxx" !b
func Test${1:Xxx}(t *testing.T) {
	t.Error("pending")
}
endsnippet

snippet ftm "func TestMain" !b
func TestMain(m *testing.M) {
	os.Exit(func() int {
		return m.Run()
	}())
}
endsnippet

snippet tr "t.Run" !b
t.Run(${1:fmt.Sprintf("%#v", ${2:v})}, func(t *testing.T) {
	${0:// TODO: not implemented yet}
})
endsnippet

snippet fb "func BenchmarkXxx" !b
func Benchmark${1:Xxx}(b *testing.B) {
	for i := 0; i < b.N; i++ {
		${0:// TODO: not implemented yet}
	}
}
endsnippet

snippet fe "func ExampleXxx" !b
func Example${1:Xxx}() {
	$0
}
endsnippet

snippet rec "if err := recover(); err != nil" !b
if err := recover(); err != nil {
	${0:panic(err)}
}
endsnippet

snippet def "defer func()" !b
defer func() {
	${0:${VISUAL}}
}()
endsnippet

snippet ifne "if !reflect.DeepEqual(...)" !b
if !reflect.DeepEqual(actual, expect) {
	t.Errorf("${1:${2:Func}(${3:%#v})} => %#v; want %#v", ${4:v}, actual, expect)
}
endsnippet

snippet pe "panic(err)" !b
panic(err)
endsnippet

snippet r "return" "re.match('\s*r(?!.*:=)', snip.buffer[snip.line])" !be
return $0
endsnippet

snippet rt "return true" !b
return true
endsnippet

snippet rf "return false" !b
return false
endsnippet

snippet re "return err" !b
return err
endsnippet

snippet rew "return errors.WithStack(err)" !b
return errors.WithStack(err)
endsnippet

snippet rn "return nil" !b
return nil
endsnippet

snippet rne "return nil, err" !b
return nil, err
endsnippet

snippet e "fmt.Errorf()" !w
fmt.Errorf("$0")
endsnippet

snippet tfe "t.Fatal(err)" !b
t.Fatal(err)
endsnippet

snippet sorter "sort.Interface" !b
func (${1:s} ${2:Slice}) Len() int {
	return len($1)
}

func ($1 $2) Less(i, j int) bool {
	return $1[i] < $1[j]
}

func ($1 $2) Swap(i, j int) {
	$1[i], $1[j] = $1[j], $1[i]
}
endsnippet

snippet ifcmp "if diff := cmp.Diff()" !b
if diff := cmp.Diff(actual, expect); diff != "" {
	t.Errorf("(-got +want)\n%v", diff)
}
endsnippet

snippet ifet "if err != nil; t.Fall(err)" !b
if err != nil {
	t.Fatalf("%+v\n", err)
}
endsnippet

snippet ifeb "if err != nil; b.Fall(err)" !b
if err != nil {
	b.Fatalf("%+v\n", err)
}
endsnippet
