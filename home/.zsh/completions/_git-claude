#compdef git-claude
#description git claude - Git worktree management for AI implementation branches

# zsh completion for git claude subcommand
# Place this file as ~/.zsh/completions/_git-claude

_git-claude() {
    local context state line
    local -a commands
    
    commands=(
        'start:Create worktree for branch'
        'end:Remove worktree and delete branch'
        'help:Show usage information'
    )
    
    case ${words[2]} in
        start)
            _arguments -C \
                '1:command:(start)' \
                '2::branch:->branch_start'
            ;;
        end)
            _arguments -C \
                '1:command:(end)' \
                '2:branch:->branch_end'
            ;;
        *)
            _arguments -C \
                '1:command:->command'
            ;;
    esac
    
    case $state in
        command)
            _describe 'claude commands' commands
            ;;
        branch_start)
            # start コマンドの場合：全てのブランチ（ローカル + リモート）を補完（省略可能）
            _git_branch_names
            ;;
        branch_end)
            # end コマンドの場合：worktreeが存在するブランチのみを補完（必須）
            _git_claude_worktree_branches
            ;;
    esac
}

# メインリポジトリのパスを取得する関数
_git_claude_get_main_repo_root() {
    # git worktree listの最初の行がメインのリポジトリ
    git worktree list 2>/dev/null | head -n1 | awk '{print $1}'
}

# worktreeが存在するブランチを取得する関数
_git_claude_worktree_branches() {
    local -a worktree_branches
    local main_repo_root repo_name worktree_path branch_name current_worktree_path
    local in_worktree=0
    
    # メインリポジトリのパスを取得
    main_repo_root=$(_git_claude_get_main_repo_root)
    
    if [[ -n "$main_repo_root" ]]; then
        # メインリポジトリのパスからリポジトリ名を取得
        repo_name=$(basename "$main_repo_root")
        
        # git worktree list --porcelain の出力を解析
        # 形式:
        # worktree /path/to/worktree
        # HEAD commit_hash
        # branch refs/heads/branch_name
        while IFS= read -r line; do
            if [[ "$line" =~ '^worktree (.+)' ]]; then
                current_worktree_path="${match[1]}"
                in_worktree=1
            elif [[ $in_worktree -eq 1 ]] && [[ "$line" =~ '^branch refs/heads/(.+)' ]]; then
                branch_name="${match[1]}"
                local dir_name=$(basename "$current_worktree_path")
                
                # リポジトリ名のプレフィックスを持つディレクトリかチェック
                # かつメインリポジトリでないことを確認
                if [[ "$dir_name" =~ "^${repo_name}-" ]] && [[ "$current_worktree_path" != "$main_repo_root" ]]; then
                    worktree_branches+=("$branch_name")
                fi
                in_worktree=0
            elif [[ "$line" == "" ]]; then
                # 空行でworktreeエントリの終了
                in_worktree=0
            fi
        done < <(git worktree list --porcelain 2>/dev/null)
    fi
    
    _describe 'worktree branches' worktree_branches
}

# git のブランチ名補完関数（ローカル + リモート）
_git_branch_names() {
    local -a branches
    local branch
    
    # ローカルブランチを追加
    while read -r branch; do
        [[ -n "$branch" ]] && branches+=("$branch")
    done < <(git for-each-ref --format='%(refname:short)' refs/heads/ 2>/dev/null)
    
    # リモートブランチを追加（origin/ プレフィックスを除去）
    while read -r branch; do
        if [[ "$branch" =~ '^origin/(.+)$' ]]; then
            local remote_branch="${match[1]}"
            # HEADブランチは除外し、ローカルブランチと重複しない場合のみ追加
            if [[ "$remote_branch" != "HEAD" ]] && [[ ! " ${branches[*]} " =~ " ${remote_branch}" ]]; then
                branches+=("$remote_branch")
            fi
        fi
    done < <(git for-each-ref --format='%(refname:short)' refs/remotes/origin/ 2>/dev/null)
    
    _describe 'branches' branches
}

# gitのサブコマンドとして登録
compdef _git-claude git-claude
